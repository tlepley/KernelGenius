/*
  This file is part of KernelGenius.

  Copyright (C) 2013 STMicroelectronics

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 3 of the License, or (at your option) any later version.
 
  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  Lesser General Public License for more details.
 
  You should have received a copy of the GNU Lesser General Public
  License along with this program; if not, write to the Free
  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  Boston, MA 02110-1301 USA.
  
  Authors: Thierry Lepley
*/

/* Function node base class */

package ir.base;

import ir.literals.Literal;
import ir.types.Type;
import ir.types.c.Array;
import ir.types.kg.MatrixSize;
import ir.types.kg.MatrixIndexes;
import ir.types.kg.TypedMatrixIndexes;

import java.io.PrintStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import codegen.OpenCL.CLGenVarNames;

import parser.TNode;

import common.CompilerError;
import driver.options.CodegenOptions;

public abstract class FunctionNode extends KernelData {
  // Unique ID
  static int globalId=0;
  public int myId;

  // Base type given in the source file for the algorithmic node
  Type outputBaseCType=null;
  
  //===================================================================================
  // Common properties
  //===================================================================================

  Map<KernelData,BorderMode> borderProperty=new  HashMap<KernelData,BorderMode>();

  //===================================================================================
  // Graph connectivity
  //===================================================================================

  // Node inputs (as declared in the source file)
  LinkedList<KernelData> inputDataList= new LinkedList<KernelData>();
  HashMap<String,KernelData> inputDataMap= new HashMap<String,KernelData>();
  
  // Graph inputs (related to the abstract graph model)
  LinkedList<DataEdge> inputEdgeList=new LinkedList<DataEdge>();
  Map<KernelData,DataEdge> inputEdgeMap= new HashMap<KernelData,DataEdge>();

  
  protected void removeInputEdge(DataEdge de) {
    inputEdgeList.remove(de);
    inputEdgeMap.remove(de);
  }

  //===================================================================================
  // Node pattern information
  //===================================================================================
 
  // Input read union
  MatrixIndexes readPatternUnion = null;
  // Stride patterns
  public MatrixSize inputStridePattern = null;
  public MatrixSize outputStridePattern = null;
  // Write pattern
  public MatrixIndexes writePattern = null;

  
  //========================================================
  // Code generation options
  //========================================================
  
  // The Algorithm class handles the code generation of the main kernel function, that corresponds
  // to loops over dimension >=1 of data that bring data locally. This function calls computation
  // function that are generated by particular algorithms and that ma y need to position themselves
  // in the data iteration space (for border management for instance)
  boolean needPosition=false;
  public void setNeedPosition() {
    needPosition=true;
  }
  public boolean needPosition() {
    return needPosition;
  }
 
  
  //========================================================
  // Tile analysis
  //========================================================
  public MatrixSize nbBlocksPerTileGrainForGraph=null;

  
  //==================================================================
  // Getters (Patterns)
  //==================================================================
 
  //-------------------------- Inputs ---------------------------  
   public MatrixIndexes getReadPatternUnion() {
    return readPatternUnion;
  }
  public MatrixSize getInputStridePattern() {
    return inputStridePattern;
  }


  //-------------------------- Outputs ---------------------------
  public MatrixIndexes getWritePattern() {
    return writePattern;
  }
  public MatrixSize getOutputStridePattern() {
    return outputStridePattern;
  }


  //==================================================================
  // Getters (all input data / iterative and control)
  //==================================================================
  
  public List<KernelData> getInputDataList() {
    return inputDataList;
  }  
  public int getNbInputData() {
    return inputDataList.size();
  }
  public KernelData getInputData(int i) {
    return inputDataList.get(i);
  }
  public KernelData getInputData(String s) {
    return inputDataMap.get(s);
  }
  
  //--- Temporary: To remove ---
  public KernelData getFirstInputData() {
    return inputDataList.get(0);
  }

    
  //==================================================================
  // Getters (graph / Iterative inputs)
  //==================================================================
 
  public List<DataEdge> getInputEdgeList() {
    return inputEdgeList;
  }
  public int getNbInputEdges() {
    return inputEdgeList.size();
  }
  public DataEdge getInputEdge(int i) {
    return inputEdgeList.get(i);
  }
  public DataEdge getInputEdge(KernelData kd) {
    return inputEdgeMap.get(kd);
  }

  //--- Temporary: To remove ---
  public DataEdge getFirstInputEdge() {
    return inputEdgeList.get(0);
  }
  
  public void getImplicitControlParamList(HashSet<KernelData> kdSet) {
    // Iterative inputs
     for(DataEdge de:inputEdgeList) {
       de.getSourceData().getMatrixType().getIndexRangeSpecifiers(kdSet);
     }
   }
 
  //==================================================================
  // Getters (output)
  //==================================================================

  // Outputs
  public Type getOutputBaseCType() {
    return outputBaseCType;
  }

  public boolean isSkipOrUndef() {
    boolean skip_undef=false;
    for(DataEdge ed:getInputEdgeList()) {
      skip_undef |= ed.getBorderMode().isSkipOrUndef();
    }
    return skip_undef;
  }

  
  //========================================================
  // Building
  //========================================================

  public FunctionNode() {
    // Unique id (for example for code generation mangling)
    myId=globalId++;
    
    // TODO: The output of an algorithm is by default iterative, what may not be 
    // always the case in the future. The result of an algorithm can be a single value
    // (reduction) and a variable set of structures (keypoint list)
    setIterative();
  }
  
  public static FunctionNode getNewAlgorithmFromName(String s, TNode tn, CompilerError ce) {
    Class<?> t=null;
    try {
      t=Class.forName("ir.algorithms."+s);
    }
    catch(ClassNotFoundException e) {
      ce.raiseFatalError(tn, "no Algorithmic node type '"+s+"'");
    }
    
    Class<? extends FunctionNode>  c=null;
    try {
       c = t.asSubclass(FunctionNode.class);
    }
    catch(ClassCastException e) {
      ce.raiseInternalError(tn, "getNewAlgorithmFromName("+s+"), ClassCastException");
    }
       
    FunctionNode a=null;
    try {
      a=c.newInstance();
    }
    catch(InstantiationException e) {
      ce.raiseInternalError(tn, "getNewAlgorithmFromName("+s+"), InstantiationException");
    }
    catch(IllegalAccessException e) {
      ce.raiseInternalError(tn, "getNewAlgorithmFromName("+s+"), IllegalAccessException");
    }
    return a;
  }
  
  public void setName(String s, TNode tn) {
    super.setName(s,tn);
  }

  public void setOutputBaseCType(Type t, TNode bn) {
    outputBaseCType=t;
    setBaseCTypeNode(bn);
  }

  // All inputs
  public void addInputData(KernelData kd) {
    inputDataList.add(kd);
    inputDataMap.put(kd.getName(),kd);
  }

  // Iterative input
  protected DataEdge addInputEdge(KernelData kd) {
    kd.setIterative();
    DataEdge de=new DataEdge(kd,this); 
    addInputEdge(de);  
    return de;
  }
  
  // Iterative input : for macro node creation
  protected void addInputEdge(DataEdge de) {    
    // Attach to the target
    inputEdgeList.add(de);
    inputEdgeMap.put(de.getSourceData(),de);
    // Attach to the source
    de.getSourceData().addUserEdge(de);
  }
 
  //------ access patterns ------
  protected void setInputStrideNoCheck(MatrixSize m) {
    inputStridePattern=m;
  }

  protected void setInputStride(MatrixSize m, TNode tn, CompilerError ce) {
    if (inputStridePattern!=null) {
      ce.raiseWarning(tn,"redefining the input stride property");
    }
    inputStridePattern=m;
  }
 
  protected void setWritePattern(MatrixIndexes m) {
    writePattern=m;
  }

  protected void setOutputStrideNoCheck(MatrixSize m) {
    outputStridePattern=m;
  }

  protected void setOutputStride(MatrixSize m, TNode tn, CompilerError ce) {
    if (outputStridePattern!=null) {
      ce.raiseWarning(tn,"redefining the output stride property");
    }
    outputStridePattern=m;
  }
  
  
  //------ Properties setters ------
  
  abstract public void setProperty(String prop, List<KernelData> param, TNode tn, CompilerError ce);
  abstract public void setPropertyWithIdentifier(String prop, List<KernelData> param, String ident, TNode tn, CompilerError ce);
  abstract public void setPropertyWithArrayRange(String prop, List<KernelData> param, Array array, TNode tn, CompilerError ce);
  abstract public void setPropertyWithLiteral(String prop, List<KernelData> param, Literal array, TNode tn, CompilerError ce);
  abstract public void setPropertyWithString(String prop, List<KernelData> param, String s, TNode tn, CompilerError ce);
  
  // Error management  
  public void raiseUnknownIdentifierPropertyError(String prop, TNode tn, CompilerError ce) {
    ce.raiseError(tn,"Node '"+this.getClass().getSimpleName()+"': unknown identifier property '"+prop+"' ");
  }
  public void raiseUnknownStringPropertyError(String prop, TNode tn, CompilerError ce) {
    ce.raiseError(tn,"Node '"+this.getClass().getSimpleName()+"': unknown string property '"+prop+"' ");
  }
  public void raiseUnknownArrayRangePropertyError(String prop, TNode tn, CompilerError ce) {
    ce.raiseError(tn,"Node '"+this.getClass().getSimpleName()+"': unknown array property '"+prop+"' ");
  }
  public void raiseUnknownLiteralPropertyError(String prop, TNode tn, CompilerError ce) {
    ce.raiseError(tn,"Node '"+this.getClass().getSimpleName()+"': unknown literal property '"+prop+"' ");
  }
  public void raiseUnknownPropertyValueError(String prop, String value, TNode tn, CompilerError ce) {
    ce.raiseError(tn,"Node '"+this.getClass().getSimpleName()+"', property '"+prop+"': wrong value '"+value+"' ");
  }
  public void raiseParamPropertyError(String prop, TNode tn, CompilerError ce) {
    ce.raiseError(tn,"Node '"+this.getClass().getSimpleName()+"': Property '"+prop+"' can not be associated to a node input");
  }
  public void raisePropertyError(String Message, String prop, TNode tn, CompilerError ce) {
    ce.raiseError(tn,"Node '"+this.getClass().getSimpleName()+"', property '"+prop+"': "+Message);
  }


  //------ Border ------
  protected void setBorderProperty(KernelData kd, BorderMode b, TNode tn, CompilerError ce) {
    if (borderProperty.containsKey(kd)) {
      ce.raiseWarning(tn,"redefining the border property for '"+kd.getName()+"'");
    }
    borderProperty.put(kd,b);
  }
  
  //==================================================================
  // Data access patterns for answering the quation:
  // for computing an output value, what input pattern do we need ?
  //==================================================================

  public void applyAccessPatternUnion() {
    // Apply the read type to inputs    
    for(DataEdge ed:inputEdgeList) {
      ed.getSourceData().getAccessPatternUnion().union(ed.getReadPattern());
    }
 
    // Apply the write type to itself
    getAccessPatternUnion().union(getWritePattern());
  }
   
  abstract public void applyAccessPatternContraints();
  
  
  //==================================================================
  // Check
  //==================================================================
  
  // Specific node check
  abstract protected boolean completeAndCheckNode(CompilerError ce);
    
  
  void processBorder(CompilerError ce) {
    // Set user border properties
    for(KernelData kd:borderProperty.keySet()) {
      if (!kd.isIterative()) {
        // May be due to a border property without specified input 
        ce.raiseWarning(1,getNameNode(),getName()+
            ": border property specified on a non iterative input '"+kd.getName()+"'");

      }
      else {
        getInputEdge(kd).setBorderMode(borderProperty.get(kd));
      }   
    }

    // Set default border mode
    for(DataEdge ed:inputEdgeList) {
      if (!ed.hasBorderDefined()) {
        ed.setBorderMode(BorderMode.Default);
        ce.raiseWarning(1,getNameNode(),getName()+": taking default border type for input '"+
            ed.getSourceData().getName()+"': "+BorderMode.Default.toString());
      }  
    }
    
    // Optionally Mirror the read pattern
    for(DataEdge ed:inputEdgeList) {
      if (ed.getBorderMode().isMirror()) {
        ed.getReadPattern().symmetryUnion();
      }
    }
  }

  void computeOutputSkipPattern() {
    // Output border computation to skip -> merge read pattern patterns
    // Note: for UNDEF, we may not need to skip the computation of border outputs if it simplifies the generated code
    for(DataEdge ed:inputEdgeList) {
      BorderMode bm=ed.getBorderMode();
      if (bm.isSkipOrUndef()) {
        addOutputSkipPattern(ed.getReadPattern());
      }
    }
  }

  void computeOutputMatrixType() {
    // Take the first iterative input to get the output iterative space
    // We should first check the consistency of all inputs
    DataEdge ed=getFirstInputEdge();
    KernelData kd=ed.getSourceData();

    TypedMatrixIndexes type=new TypedMatrixIndexes(outputBaseCType,kd.getMatrixType()); // duplicate
    for (int i=0;i<kd.getMatrixType().getNbDims();i++) {
      // The code generation is today for the 'ceiling'
      type.amplifyDivBy(i,0,inputStridePattern.getNbElements(i),true);
      type.amplifyMulBy(i,0,outputStridePattern.getNbElements(i),true);
    }
    setMatrixType(type);
  }


  public void completeAndCheck(CompilerError ce) {
    // Daughter class check/completion
    if (completeAndCheckNode(ce)) {
      // Data may be partially computed, we can stop here
      return;
    }
      
    // Check border management
    processBorder(ce);

    // Complete remaining access patterns
    for(DataEdge de:inputEdgeList) {     

      // Compute the read pattern union
      if (readPatternUnion==null) {
        readPatternUnion=new MatrixIndexes(de.getReadPattern());
      }
      else {
        readPatternUnion.union(de.getReadPattern());
      }

      // Computes the minimum read pattern
      // -> we can start to work as soon as we get the down elements
      MatrixIndexes mtmp=new MatrixIndexes(de.getReadPattern());
      mtmp.setFirstIndexesAsZero();
      de.minReadPattern=mtmp;
    }

    // TODO: We take the first iterative input but we should check the compatibility between all iterative inputs first
    // Set the output type of the node (deduced from the node output type, the iterative inputs size
    // and stride patterns)
    computeOutputMatrixType();

    // Manage SKIP / UNDEF borders
    computeOutputSkipPattern();
    
     
    // TODO: Manage the non dense output generation (this is a complex item for which we would better have a real use case) 
    // Check for dense output pattern. If the output is not dense, KernelGenius may also have to bring
    // into the accelerator a part of the output buffer since all data of the output that are non written
    // are implicitly also an input of the node.
    if (!writePattern.includes(outputStridePattern)) {
      ce.raiseError(getNameNode(), "the stride pattern ("+outputStridePattern+") is larger than the write pattern ("+writePattern+
          ") for Filter '"+getName()+"'. This non-dense output generation pattern is not (yet) supported");
    }
    
  }
  
  
  
  // ==================================================================
  // Analysis
  // ==================================================================
  
  protected void computeTileGrainForSuccessors() {    
    // Output stride for graph leaves
    setTileGrainForSuccessors(new MatrixSize(getOutputStridePattern()));    
    for(DataEdge de:getUserEdgeList()) {
      getTileGrainForSuccessors().lcm(de.getTileInGrainConstraint());
    }
  }  
  
  // For KernelData that is not a function node
  protected void computeNbhForSuccessors() {
    // Start with [0:0, 0:0] matrix
    setTileNbhForSuccessors(new MatrixIndexes(MatrixIndexes.MatrixSingleElementCentered));
    for(DataEdge de:getUserEdgeList()) {
      getTileNbhForSuccessors().union(de.getTileInNbhConstraint());
    }
    // OLD: Multiple of the block size
    //getTileNbhForSuccessors().inflateToMultipleOf(getOutputStridePattern());
    // Multiple of the grain size
    getTileNbhForSuccessors().inflateToMultipleOf(getTileGrainForGraph());
  }

  
  protected void computeTileGrainForGraph(DataEdge edge) {
    // Compute only once
    if (getTileGrainForGraph()==null) {
      if (edge==null) {
        // No ancestor like kernel inputs
        setTileGrainForGraph(getTileGrainForSuccessors());
        setTileExecutionRateForGraph(new MatrixSize(getTileGrainForGraph()).devideDirectBy(getOutputStridePattern()));
      }
      else {
        MatrixSize tile=new MatrixSize(edge.getSourceData().getTileGrainForGraph());
        tile.devideDirectBy(getInputStridePattern());
        setTileExecutionRateForGraph(new MatrixSize(tile));
        tile.multiplyDirectBy(getOutputStridePattern());
        setTileGrainForGraph(tile);
      }

      nbBlocksPerTileGrainForGraph=new MatrixSize(getTileGrainForGraph())
      .devideDirectBy(getOutputStridePattern());

      // Recursive traversal
      for(DataEdge de:getUserEdgeList()) {
        de.getTargetFunctionNode().computeTileGrainForGraph(de);
      } 
    }
  }

  public int getPush() {
    return getOutputStridePattern().getNbElements(1);
  }
  
  public void computeSchedulingForward() {
    //==================================================
    // NEW scheduling
    //==================================================
    int cycle=0;
 
    // Take the max of the the scheduling info of inputs
    for(DataEdge de:inputEdgeList) {
      int sync=(CodegenOptions.isAsyncMergeMode()||
          !(de.getSourceData() instanceof FunctionNode))
          ?0:1;
      
      int dep=(2*de.getPop()*getRate()+de.getPeekMax()-1)/(de.getPop()*getRate())-sync;
      //int dep=(2*de.getSourceData().getTileGrainForGraph().getNbElements(1)+
      //         de.getReadPattern().getLastIndex(1)-1)
      //        /de.getSourceData().getTileGrainForGraph().getNbElements(1)
      //        -sync;
      de.setDependency(dep);
      // Cycle related to this edge
      int depCycle=de.getSourceData().getCodegenDataPattern().getSchedulingCycle()+dep;
      // Take the max cycle
      cycle=depCycle>cycle?depCycle:cycle;
    }
 
    // Set the scheduling information
    getCodegenDataPattern().setSchedulingCycle(cycle);
  }

  
  // ==================================================================
  // Code generation
  // ==================================================================
  
  abstract public void generateConstLiterals(PrintStream ps);

  public abstract void generateRuntimeFunctions(PrintStream ps);

  //public abstract void generateImageComputeFunctionBody(PrintStream ps);

  protected abstract  void generateNodeComputeFunction(
      List<Integer> firstIndexList,
      List<Integer> lastIndexList,
      List<String> lastIndexStringPlusOneList, 
      Set<KernelData> internalData,
      PrintStream ps,
      String prefix); 
  
  // Generic scaling
  static void generateStrideMultiplication(MatrixSize stridePattern, int dim, PrintStream ps) {
    if (stridePattern.getNbElements(dim)!=1) {
      ps.print("*");
      ps.print(stridePattern.getNbElements(dim));
    }
  }
  
  static void generateStrideDivision(MatrixSize stridePattern, int dim, PrintStream ps) {
    if (stridePattern.getNbElements(dim)!=1) {
      ps.print("/");
      ps.print(stridePattern.getNbElements(dim));
    }
  }

  // Input scaling 
  protected void generateInputStrideMultiplication(int dim, PrintStream ps) {
    generateStrideMultiplication(getInputStridePattern(),dim,ps);
  }
  
  // Output scaling 
  protected void generateOutputStrideMultiplication(int dim, PrintStream ps) {
    generateStrideMultiplication(getOutputStridePattern(),dim,ps);
  }
  
  protected void generateOutputStrideDivision(int dim, PrintStream ps) {
    generateStrideDivision(getOutputStridePattern(),dim,ps);
  }

  protected void generateAbsoluteTilePositionInPixelInput(int n,PrintStream ps) {
    if (n>0) {   
      CLGenVarNames.generatePositionPixUnit(this,n,ps);
    }
    else {
      ps.print("(");
      CLGenVarNames.generateMyWGSlicePositionBlockUnit(this,0,ps);
      generateInputStrideMultiplication(n,ps);
      ps.print(")");
    }
  }

  protected void generateAbsoluteWIPositionNodeInPixelInput(int n,PrintStream ps) {
    if (n>0) {   
      ps.print("(");
      CLGenVarNames.generatePositionPixUnit(this,n,ps);
      generateOutputStrideDivision(n,ps);
      ps.print(")");
      generateInputStrideMultiplication(n,ps);
    }
    else {
      ps.print("(");
      ps.print("(");
      CLGenVarNames.generateMyWGSlicePositionBlockUnit(this,0,ps);
      ps.print("+");
      CLGenVarNames.generateComputeLoopBlockCounter(ps);
      ps.print(")");
      generateInputStrideMultiplication(n,ps);
      ps.print(")");
    }
  }

  protected void generateSkipBeginVarDeclarationBlock(MatrixIndexes m, int n, PrintStream ps, String prefix) {
    ps.print(prefix);
    ps.print("int ");
    CLGenVarNames.generateSkipBeginBlockUnit(this,n,ps);
    ps.print("=");
    generateAbsoluteTilePositionInPixelInput(n,ps);
    ps.print(">=");
    ps.print(-getOutputSkipPattern().getFirstIndex(n));
    ps.print("?");
    ps.print("0:");
    int stride=getInputStridePattern().getNbElements(n);
    if (stride!=1){
      ps.print("(");
    }
    ps.print(-getOutputSkipPattern().getFirstIndex(n));
    ps.print("-");
    generateAbsoluteTilePositionInPixelInput(n,ps);
    if (stride>1){
      ps.print("+");
      ps.print(stride-1);
    }
    if (stride!=1){
      ps.print(")");
    }
    if (stride>1){
      ps.print("/");
      ps.print(stride);
    }
    ps.println(";");
  }


  protected void generateSkipEndVarDeclarationBlock(MatrixIndexes m, int n, boolean readUnion, PrintStream ps, String prefix) {
    ps.print(prefix);
    ps.print("int ");
    CLGenVarNames.generateSkipEndBlockUnit(this,n,ps);
    ps.print("=");
    // Position to the beginning of the last block
    generateAbsoluteTilePositionInPixelInput(n,ps);
    ps.print("+");
    ps.print("(");
    CLGenVarNames.generateMyWGSliceSizeBlockUnit(this,n, ps);
    ps.print("+");
    CLGenVarNames.generateMyWGSliceRightExtentBlockUnit(this,n,ps);
    ps.print("-1");
    ps.print(")");
    int stride=getInputStridePattern().getNbElements(n);
    if (stride!=1){
      ps.print("*");
      ps.print(stride);
    }
    // Add the read union pattern to see if we go out of the border
    ps.print("+");
    if (readUnion) {
      ps.print(getReadPatternUnion().getLastIndex(n));
    }
    else {
      ps.print(getOutputSkipPattern().getLastIndex(n));
    }
    ps.print("<");
    m.generateLastIndexPlusOne(n,ps);
    ps.print("?");
    ps.print("0:");

    if (stride!=1){
      ps.print("(");
    }
    generateAbsoluteTilePositionInPixelInput(n,ps);
    ps.print("+"); 
    ps.print("(");
    CLGenVarNames.generateMyWGSliceSizeBlockUnit(this,n, ps);
    ps.print("+");
    CLGenVarNames.generateMyWGSliceRightExtentBlockUnit(this,n,ps);
    ps.print("-1");
    ps.print(")"); 
    if (stride!=1){
      ps.print("*");
      ps.print(stride);
    }
    ps.print("+");
    if (readUnion) {
      ps.print(getReadPatternUnion().getLastIndex(n));
    }
    else {
      ps.print(getOutputSkipPattern().getLastIndex(n));
    }
    ps.print("+1");
    ps.print("-");
    m.generateLastIndexPlusOne(n,ps);
    if (stride>1){
      ps.print("+");
      ps.print(stride-1);
    }
    if (stride!=1){
      ps.print(")");
    }
    if (stride>1){
      ps.print("/");
      ps.print(stride);
    }
    ps.println(";");
  }

  public void generateSkipBeginVarDeclarationPix(int n, PrintStream ps, String prefix) {
    ps.print(prefix);
    ps.print("int ");
    CLGenVarNames.generateSkipBeginPixUnit(this,n,ps);
    ps.print("=");
    CLGenVarNames.generateMySlicePositionPixUnit(this,n,ps);
    ps.print(">=");
    ps.print(-getOutputSkipPattern().getFirstIndex(n));
    ps.print("?");
    ps.print("0:");
    ps.print("min(");
    CLGenVarNames.generateMyWGSliceSizePixUnit(this,n,ps);
    ps.print(",");
    ps.print(-getOutputSkipPattern().getFirstIndex(n));
    ps.print("-");
    CLGenVarNames.generateMySlicePositionPixUnit(this,n,ps);
    ps.println(");");
  }

  public void generateSkipEndVarDeclarationPix(int n, PrintStream ps, String prefix) {
    ps.print(prefix);
    ps.print("int ");
    CLGenVarNames.generateSkipEndPixUnit(this,n,ps);
    ps.print("=");
    CLGenVarNames.generateMySlicePositionPixUnit(this,n,ps);
    ps.print("+(");
    CLGenVarNames.generateMyWGSliceSizePixUnit(this,n,ps);
    ps.print("-1)");
    ps.print("+");
    ps.print(getOutputSkipPattern().getLastIndex(n));
    ps.print("<");
    getMatrixType().generateLastIndexPlusOne(n,ps);
    ps.print("?");
    ps.print("0:");
    ps.print("min(");
    CLGenVarNames.generateMyWGSliceSizePixUnit(this,n,ps);
    ps.print(",");
    CLGenVarNames.generateMySlicePositionPixUnit(this,n,ps);
    ps.print("+(");
    CLGenVarNames.generateMyWGSliceSizePixUnit(this,n,ps);
    ps.print("-1)");
    ps.print("+");
    ps.print(getOutputSkipPattern().getLastIndex(n));
    ps.print("+1");
    ps.print("-");
    getMatrixType().generateLastIndexPlusOne(n,ps);
    ps.println(");");
  }

  
  
  public void generateImageComputeFunctionBody(
      PrintStream ps) {
 
    MatrixIndexes dataIterationSpace=getFirstInputEdge().getSourceData().getMatrixType();

    // Notes: should receive a circular buffer
    //        considers a 1D-Range

    // OpenCL variables declarations
    CLGenVarNames.generateLocalInfoVarDeclaration(0,ps,"  ");
    ps.println();
      
    // Skip begin and end management
    if (isSkipOrUndef()) {
      generateSkipBeginVarDeclarationBlock(dataIterationSpace,0,ps,"  ");
    }
    // Border management: Consider readPatternUnion instead of SkipPattern
    generateSkipEndVarDeclarationBlock(dataIterationSpace,0,true,ps,"  ");
    ps.println();

    // Compute loop counters
    generateLoopCounterDeclaration(ps,"  ");
    ps.println();
    
    // Variables to compute indexes
    boolean flag=false;
    for(DataEdge ed:getInputEdgeList()) {
      if (ed.getBorderMode().isConstValue()) {
        flag=true; break;
      }
    }
    if (flag) {
      CLGenVarNames.generateIndexDeclaration(0,ps,"  ");
      CLGenVarNames.generateIndexDeclaration(1,ps,"  ");
    }

    List<Integer> firstIndex=new LinkedList<Integer>();
    List<Integer> lastIndex=new LinkedList<Integer>();
    List<String> lastIndexStringPlusOne=new LinkedList<String>();

    int n=dataIterationSpace.getNbDims();
    if (n>1) {
      generateComputeFunctionBodyN(dataIterationSpace, n-1,firstIndex,lastIndex,lastIndexStringPlusOne, ps, "  ");
    }
    else {
      generateComputeFunctionBodyFinal(dataIterationSpace, n-1,firstIndex,lastIndex,lastIndexStringPlusOne, ps, "  ");
    }
  }


  protected void generateComputeFunctionBodyN(
      MatrixIndexes dataFullIterationSpaceInput,
      int n, 
      List<Integer> firstIndexList,
      List<Integer> lastIndexList,
      List<String> lastIndexStringPlusOneList,
      PrintStream ps,
      String prefix) {
    String newPrefix=prefix+"  ";

    //===================================================================
    // Specific code generation pattern for SKIP and UNDEF
    //===================================================================
    
    if ((getOutputSkipPattern().getFirstIndex(n)!=0) ||
        (getOutputSkipPattern().getLastIndex(n)!=0)) {
      ps.print(prefix);
      ps.print("if (");
      // Left
      if (getOutputSkipPattern().getFirstIndex(n)!=0) {
        ps.print("(");
        generateAbsoluteWIPositionNodeInPixelInput(n,ps);
        ps.print("<");
        ps.print(-getOutputSkipPattern().getFirstIndex(n));
        ps.print(")");
        ps.print("||");
      }
      // Right
      if (getOutputSkipPattern().getLastIndex(n)!=0) {
        ps.print("(");
        generateAbsoluteWIPositionNodeInPixelInput(n,ps);
        ps.print(">");
        dataFullIterationSpaceInput.generateLastIndexPlusOne(n,ps);
        ps.print("-");
        ps.print(getOutputSkipPattern().getLastIndex(n)+1);
        ps.print(")");
      }
      // -> action
      ps.println(") { return; }");
      ps.println();
    }

    boolean notfirst=false;
    firstIndexList.add(0,getReadPatternUnion().getFirstIndex(n));
    lastIndexList.add(0,getReadPatternUnion().getLastIndex(n));
    lastIndexStringPlusOneList.add(0,getFirstInputEdge().getSourceData().getMatrixType().getLastIndexPlusOneString(n));

    // Left 
    firstIndexList.remove(0);    
    for (int i=getOutputSkipPattern().getFirstIndex(n);
        i>getReadPatternUnion().getFirstIndex(n);
        i--) {
      ps.print(prefix);
      if (notfirst) { ps.print("else ");} else {notfirst=true;}
      ps.print("if (");
      generateAbsoluteWIPositionNodeInPixelInput(n,ps);
      ps.print("==");
      ps.print(-i);
      ps.println(") {");
      firstIndexList.add(0,i);
      if (n>1) {
        generateComputeFunctionBodyN(dataFullIterationSpaceInput, n-1,firstIndexList, lastIndexList, lastIndexStringPlusOneList, ps, newPrefix);
      }
      else {
        generateComputeFunctionBodyFinal(dataFullIterationSpaceInput, n-1,firstIndexList, lastIndexList, lastIndexStringPlusOneList, ps, newPrefix);
      }
      firstIndexList.remove(0);
      ps.print(prefix);
      ps.println("}");

    }
    firstIndexList.add(0,getReadPatternUnion().getFirstIndex(n));

    // Right
    lastIndexList.remove(0);
    for (int i=getOutputSkipPattern().getLastIndex(n);
        i<getReadPatternUnion().getLastIndex(n);
        i++) {
      ps.print(prefix);
      if (notfirst) { ps.print("else ");} else {notfirst=true;}
      ps.print("if (");
      generateAbsoluteWIPositionNodeInPixelInput(n,ps);
      ps.print("==");
      dataFullIterationSpaceInput.generateLastIndexPlusOne(n,ps);
      ps.print("-");
      ps.print(i+1);
      ps.println(") {");
      lastIndexList.add(0,i);
      if (n>1) {
        generateComputeFunctionBodyN(dataFullIterationSpaceInput, n-1,firstIndexList, lastIndexList, lastIndexStringPlusOneList, ps, newPrefix);
      }
      else {
        generateComputeFunctionBodyFinal(dataFullIterationSpaceInput, n-1,firstIndexList, lastIndexList, lastIndexStringPlusOneList, ps, newPrefix);
      }
      lastIndexList.remove(0);
      ps.print(prefix);
      ps.println("}");         
    }
    lastIndexList.add(0,getReadPatternUnion().getLastIndex(n));

    // Central 
    if (notfirst) { ps.print(prefix); ps.println("else {");}
    if (n>1) {
      generateComputeFunctionBodyN(dataFullIterationSpaceInput, n-1,firstIndexList, lastIndexList, lastIndexStringPlusOneList, ps, notfirst?newPrefix:prefix);
    }
    else {
      generateComputeFunctionBodyFinal(dataFullIterationSpaceInput, n-1,firstIndexList, lastIndexList, lastIndexStringPlusOneList,ps, notfirst?newPrefix:prefix);
    }
    if (notfirst) { ps.print(prefix); ps.println("}");}

    // Clean lists
    firstIndexList.remove(0);
    lastIndexList.remove(0);
    lastIndexStringPlusOneList.remove(0);
  }

  void generateLoopCounterDeclaration(PrintStream ps, String prefix) {
    // Block loop counter
    ps.print(prefix);
    ps.print("int ");
    CLGenVarNames.generateComputeLoopBlockCounter(ps);
    ps.print("=");
    generateFinalLoopInitBlock(ps);
    
    // Input counters
    for(KernelData kd:getInputDataList()) {
      ps.print(",");
      CLGenVarNames.generateComputeLoopCounterPix(kd,ps);
      ps.print("=");
      generateFinalLoopInitInputPix(ps);
    }
    
    // Output counter
    ps.print(",");
    CLGenVarNames.generateComputeLoopCounterPix(this,ps);
    ps.print("=");
    generateFinalLoopInitOutputPix(ps);
    
    ps.println(";");
  }

  void generateFinalLoopCounterShift(PrintStream ps) {
    // Block loop counter
    CLGenVarNames.generateComputeLoopBlockCounter(ps);
    ps.print("+=");
    CLGenVarNames.generateSkipBeginBlockUnit(this,0,ps);
    
    // Input counters
    for(KernelData kd:getInputDataList()) {
      ps.print(",");
      CLGenVarNames.generateComputeLoopCounterPix(kd,ps);
      ps.print("+=");
      CLGenVarNames.generateSkipBeginBlockUnit(this,0,ps);
      generateInputStrideMultiplication(0,ps);
    }

    // Output counter
    ps.print(",");
    CLGenVarNames.generateComputeLoopCounterPix(this,ps);
    ps.print("+=");
    CLGenVarNames.generateSkipBeginBlockUnit(this,0,ps);
    generateOutputStrideMultiplication(0,ps);
 
    ps.print(";");
  }
  

  protected void appendLoopCounter(KernelData kd, StringBuffer ps) {
    CLGenVarNames.appendComputeLoopCounterPix(kd,ps);
  }

  // Dim 0 : Loop initialization
  void generateFinalLoopInitBlock(PrintStream ps) {
    ps.print("-");
    CLGenVarNames.generateMyWGSliceLeftExtentBlockUnit(this,0,ps);
    ps.print("+");
    ps.print(CLGenVarNames.getLocalIdVarName(0));
  }
  void generateFinalLoopInitInputPix(PrintStream ps) {
    ps.print("(");
    generateFinalLoopInitBlock(ps);
    ps.print(")");
    generateInputStrideMultiplication(0,ps);
  }
  void generateFinalLoopInitOutputPix(PrintStream ps) {
    ps.print("(");
    generateFinalLoopInitBlock(ps);
    ps.print(")");
    generateOutputStrideMultiplication(0,ps);
  }

  
  protected void generateComputeFunctionBodyFinal(
      MatrixIndexes dataFullIterationSpaceInput,
      int n,
      List<Integer> firstIndexList,
      List<Integer> lastIndexList,
      List<String> lastIndexStringPlusOneList, 
      PrintStream ps,
      String prefix) {
    String newPrefix=prefix+"  ";

    //===================================================================
    // Specific code generation pattern for SKIP and UNDEF
    //===================================================================

    firstIndexList.add(0,getReadPatternUnion().getFirstIndex(n));
    lastIndexList.add(0,getReadPatternUnion().getLastIndex(n));
    lastIndexStringPlusOneList.add(0,getFirstInputEdge().getSourceData().getMatrixType().getLastIndexPlusOneString(n));

    // Left (undef/skip)
    firstIndexList.remove(0);    
    for (int i=0;
        i>getOutputSkipPattern().getFirstIndex(n);
        i--) {
      ps.print(prefix);
      ps.print("if (");
      generateAbsoluteWIPositionNodeInPixelInput(n,ps);
      ps.print("==");
      ps.print(-i);
      ps.println(") {");
      ps.print(newPrefix);
      generateFinalLoopCounterIncrement(ps);
      ps.println(";"); 
      ps.print(prefix);
      ps.println("}");
    }
    firstIndexList.add(0,getReadPatternUnion().getFirstIndex(n));

    // Left (not undef/skip, but in the read pattern)
    firstIndexList.remove(0);    
    for (int i=getOutputSkipPattern().getFirstIndex(n);
        i>getReadPatternUnion().getFirstIndex(n);
        i--) {
      ps.print(prefix);
      ps.print("if (");
      generateAbsoluteWIPositionNodeInPixelInput(n,ps);
      ps.print("==");
      ps.print(-i);
      ps.println(") {");
      firstIndexList.add(0,i);
      generateNodeComputeFunction(firstIndexList, lastIndexList, lastIndexStringPlusOneList,new HashSet<KernelData>(),ps,newPrefix);
      firstIndexList.remove(0);    
      ps.print(newPrefix);
      generateFinalLoopCounterIncrement(ps);
      ps.println(";"); 
      ps.print(prefix);
      ps.println("}");
    }
    firstIndexList.add(0,getReadPatternUnion().getFirstIndex(n));

    // central
    ps.print(prefix);
    ps.print("for (;");
    CLGenVarNames.generateComputeLoopBlockCounter(ps);
    ps.print("<");
    //    dataFullIterationSpaceInput.generateLastIndexPlusOne(0,ps);
    CLGenVarNames.generateMyWGSliceSizeBlockUnit(this,0, ps);
    ps.print("+");
    CLGenVarNames.generateMyWGSliceRightExtentBlockUnit(this,0,ps);
    ps.print("-");
    CLGenVarNames.generateSkipEndBlockUnit(this,0,ps);
    ps.print(";");
    generateFinalLoopCounterIncrement(ps);
    ps.println(") {");
    generateNodeComputeFunction(firstIndexList, lastIndexList, lastIndexStringPlusOneList,new HashSet<KernelData>(),ps,newPrefix);
    ps.print(prefix);
    ps.println("}");

    // Right (not undef/skip, but in the read pattern)
    lastIndexList.remove(0);
    for (int i=getReadPatternUnion().getLastIndex(0)-1;i>=getOutputSkipPattern().getLastIndex(n);i--) {
      ps.print(prefix);
      ps.print("if (");
      
      ps.print("(");
      CLGenVarNames.generateComputeLoopBlockCounter(ps);
      ps.print("<");
      CLGenVarNames.generateMyWGSliceSizeBlockUnit(this,0, ps);
      ps.print("+");
      CLGenVarNames.generateMyWGSliceRightExtentBlockUnit(this,0,ps);
      ps.print(")");
      ps.print("&&"); 
      
      ps.print("(");
      generateAbsoluteWIPositionNodeInPixelInput(n,ps);
      ps.print("==");
      dataFullIterationSpaceInput.generateLastIndexPlusOne(0,ps);
      ps.print("-");
      ps.print(i+1);
      ps.print(")");

      ps.println(") {");
      lastIndexList.add(0,i);
      generateNodeComputeFunction(firstIndexList, lastIndexList, lastIndexStringPlusOneList,new HashSet<KernelData>(),ps,newPrefix);
      lastIndexList.remove(0);
      ps.print(newPrefix);
      generateFinalLoopCounterIncrement(ps);
      ps.println(";"); 
      ps.print(prefix);
      ps.println("}");
    }   
    lastIndexList.add(0,getReadPatternUnion().getLastIndex(n));

    // Right (undef/skip)
    lastIndexList.remove(0);
    for (int i=getOutputSkipPattern().getLastIndex(n)-1;i>=0;i--) {
      ps.print(prefix);
      ps.print("if (");
      generateAbsoluteWIPositionNodeInPixelInput(n,ps);
      ps.print("==");
      dataFullIterationSpaceInput.generateLastIndexPlusOne(0,ps);
      ps.print("-");
      ps.print(i+1);
      ps.println(") {");
      ps.print(newPrefix);
      generateFinalLoopCounterIncrement(ps);
      ps.println(";"); 
      ps.print(prefix);
      ps.println("}");
    }   
    lastIndexList.add(0,getReadPatternUnion().getLastIndex(n));

    // Clean lists
    firstIndexList.remove(0);
    lastIndexList.remove(0);
    lastIndexStringPlusOneList.remove(0);
  }
    
  void generateFinalLoopCounterIncrement(PrintStream ps) {
    // Loop counter
    CLGenVarNames.generateComputeLoopBlockCounter(ps);
    ps.print("+=");
    generateFinalLoopIncrement(ps);

    // Input counters
    for(KernelData kd:getInputDataList()) {
      ps.print(",");
      CLGenVarNames.generateComputeLoopCounterPix(kd,ps);
      ps.print("+=");
      generateFinalLoopIncrementInput(ps);
    }

    // Output counter
    ps.print(",");
    CLGenVarNames.generateComputeLoopCounterPix(this,ps);
    ps.print("+=");
    generateFinalLoopIncrementOutput(ps);
  }
  
  // Dim 0 :Loop increment
  void generateFinalLoopIncrement(PrintStream ps) {
    ps.print(CLGenVarNames.getLocalSizeVarName(0));
  }
  void generateFinalLoopIncrementInput(PrintStream ps) {
    ps.print(CLGenVarNames.getLocalSizeVarName(0));
    generateInputStrideMultiplication(0,ps);
  }
  void generateFinalLoopIncrementOutput(PrintStream ps) {
    ps.print(CLGenVarNames.getLocalSizeVarName(0));
    generateOutputStrideMultiplication(0,ps);
  }

  
  //==================================================================
  // Verbose
  //==================================================================
  
  void printBorderMode(StringBuffer sb) {
    for (KernelData kd:inputEdgeMap.keySet()) {
      DataEdge de=getInputEdge(kd);
      BorderMode bm=de.getBorderMode();
      sb.append(kd.getName()).append("=").append(bm.toString());
    }
  }

  public String toString() {
    StringBuffer sb = new StringBuffer();
    sb.append("node : ")
    .append(super.toString())
    .append("; ").append(Integer.toString(getNbInputData()));
    if (getNbInputData()==1) {
      sb.append(" input = ");
    }
    else {
      sb.append(" inputs = ");
    }
    int i=0;
    for (KernelData e:inputDataList) {
      if (i++ != 0) sb.append(", ");
      sb.append(e.getName());
      if (e.isKernelInputData()) {
        sb.append(" (kernel param)");
      }
      else {
        sb.append(" (algo)");
      }
    }
    // Common to derivative classes
    sb.append("; border modes : ");
    printBorderMode(sb);
    return sb.toString();
  }

}
